# This workflow will upload a Python Package using Twine when a release is created
# For more information see: https://help.github.com/en/actions/language-and-framework-guides/using-python-with-github-actions#publishing-to-package-registries

name: upload-dev-python-package

on:
  release:
    types: [created]

  workflow_dispatch:

jobs:
  deploy-private-pypi:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        architecture: ['x64']
        region: ['nyc1']

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2

      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.8'

      - name: Set up doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DO_API_TOKEN }}

      - name: Set up DigitalOcean SSH key
        run: |
          echo "${{ secrets.DO_SSH_KEY }}" > do_private_key
          chmod 600 do_private_key
          echo "${{ secrets.DO_SSH_KEY_PUB }}" > do_public_key
          chmod 600 do_public_key

      - name: Set up Dev Server SSH Key
        run: |
          echo "${{secrets.DEV_SERVER_SSH_KEY}}" > dev_private_key
          chmod 600 dev_private_key

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install setuptools wheel twine

      - name: Build Private PyPi Server Droplet
        id: create_droplet
        run: |
          DROPLET_NAME="${{ github.workflow }}-${{ github.job }}-${{ github.run_id }}"
          DROPLET_JSON=$(doctl compute droplet create $DROPLET_NAME \
            --image ubuntu-22-04-x64 \
            --size s-1vcpu-1gb \
            --region ${{ matrix.region }} \
            --ssh-keys ${{ secrets.DO_SSH_FINGERPRINT }} \
            --format ID,PublicIPv4 \
            --no-header \
            --wait \
            --output json)
          echo "$DROPLET_JSON"
          echo "DROPLET_ID=$(echo "$DROPLET_JSON" | jq '.[].id')" >> $GITHUB_ENV
          echo "DROPLET_IP=$(echo "$DROPLET_JSON" | jq -r '.[].networks.v4[0].ip_address')" >> $GITHUB_ENV

      - name: Wait for Pypi Droplet SSH
        run: |
          COUNT=0
          RETRIES=30
          while [ $COUNT -lt $RETRIES ]
            do
              echo "Attempting to connect to $DROPLET_IP as root (attempt $(($COUNT + 1))/$RETRIES)..."
              ssh -i do_private_key -o "BatchMode=yes" -o "StrictHostKeyChecking=no" -o "ConnectTimeout=5" "root@$DROPLET_IP" 'echo SSH_READY' && break
              COUNT=$(($COUNT + 1))
              sleep 5
            done
          if [ $COUNT -lt $RETRIES ]; then
            echo "SSH is ready on $DROPLET_IP"
            exit 0
          else
            echo "Failed to establish an SSH connection to $DROPLET_IP after $RETRIES attempts"
            exit 1
          fi

      - name: Configure Pypi Server
        id: config-pypi-server
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i do_private_key \
            root@$DROPLET_IP "bash -s" <<- 'ENDSSH'
              apt install python3-pip -y
              pip3 install virtualenv
              mkdir ~/packages
              cd packages
              virtualenv venv
              source venv/bin/activate
              pip install pypiserver
              nohup pypi-server -p 8080 ~/packages > pypi-server.log 2>&1 &
          ENDSSH
      - name: Build and publish
        continue-on-error: true
        env:
          TWINE_USERNAME: ${{ secrets.DEV_PYPI_USERNAME }}
          TWINE_PASSWORD: ${{ secrets.DEV_PYPI_PASSWORD }}
        run: |
          python setup.py sdist bdist_wheel
          twine upload --repository-url http://$DROPLET_IP:8080 dist/*

      - name: Clone GuillaumeFalourd/poc-github-actions PUBLIC repository
        uses: GuillaumeFalourd/clone-github-repo-action@v2
        with:
          owner: 'FreeTAKTeam'
          repository: 'FreeTAKHub-Installation'

      - name: Checkout FTS-Install Repository
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i do_private_key \
            root@${{secrets.DEV_SERVER_ADDRESS}} "bash -s" <<- 'ENDSSH'
            echo -e -n "Checking for FreeTAKHub-Installation in home directory..."
            # check for FreeTAKHub-Installation repository
            if [[ ! -d ~/FreeTAKHub-Installation ]]; then
              echo -e "NOT FOUND"
              echo -e "Cloning the FreeTAKHub-Installation repository..."
              git clone https://github.com/FreeTAKTeam/FreeTAKHub-Installation.git
            else
              echo -e "FOUND"
              cd ~/FreeTAKHub-Installation
              echo -e "Pulling latest from the FreeTAKHub-Installation repository..."
              git pull
            fi
          ENDSSH

      - name: Run Ansible Playbook
        run: |
          ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null -i do_private_key \
            root@${{secrets.DEV_SERVER_ADDRESS}} "bash -s" <<- 'ENDSSH'
            # Execute Zerotouch Script
            ~/FreeTAKHub-Installation/scripts/easy_install.sh --verbose
          ENDSSH

#      - name: Run Ansible playbook
#        # You may pin to the exact commit or the version.
#        # uses: dawidd6/action-ansible-playbook@671974ed60e946e11964cb0c26e69caaa4b1f559
#        uses: dawidd6/action-ansible-playbook@v2.5.0
#        with:
#          # Ansible playbook filepath
#          playbook: FreeTAKHub-Installation/install_all.yml
#          # SSH private key used to connect to the host
#          key: ${{secrets.DEV_SERVER_SSH_KEY}}
#          # Custom content to write into hosts
#          inventory: |
#            [all]
#            ${{secrets.DEV_SERVER_ADDRESS}}    ansible_sudo_pass=${{secrets.DEV_SERVER_PASSWORD}}     ansible_connection=ssh    ansible_user=${{secrets.DEV_SERVER_USERNAME}}
#          # Extra options that should be passed to ansible-playbook command
#          options: |
#            --verbose
#          # Set to "true" if root is required for running your playbook
#          sudo: true

      - name: Destroy droplet
        if: always()
        run: doctl compute droplet delete -f $DROPLET_ID
